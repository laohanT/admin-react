# React

## 路由渲染（Router）

### 路由渲染时，要考虑几种情况

- 已登录
- 未登录
- 没有匹配到路由

### 创建路由表（ts）

- 手动创建路由interface

  ```react
  interface RouteConfig {
      path: string,  // 地址
      element?: ReactNode, // 页面组件
      name?: string, // 名称
      icon?: ReactNode, // 菜单图标
      children?: RouteConfig[], // 子级路由
      hidden?: boolean // 是否在菜单中隐藏
  
  }
  ```

- 路由使用

  ```react
  import routes from './router/routes';
  const AppRoutes = () => {
    const routing = useRoutes(routes);
    return routing;
  }
  // 组件中使用
  <div>
       <AppRoutes />
  </div>
  ```

  

## 封装请求，携带token（fetch）

```tsx
const request = async (url,option) =>{
    // 获取token
    const token = window.sessionStorage.getItem('access_token')
    const header = new Headers(option.header)
    //判断是否有请求头
    if(!header.has('Content-Type')) {
        header.set('Content-Type',"application/json")
    }
    // 判断token是否存在
    if(token){
       header.set('token',`Bearer ${token}`) 
    }
    // 发起请求
    const response = await fetch(url,{
        header,
        ...option
    })
    // 判断是否401 处理过期逻辑
    if(response.status == 401){
        
    }
    
    return response.json()
}
```

## 代理（Proxy）

1. 直接修改package.json

   ```json
   "proxy":"http://localhost:3008" // 只能配置一个地址
   ```

2. 增加setupProxy.js文件 （/src/setuptProxy.js，就算是ts项目，文件名后缀也得是js，cra会自动执行js代理文件）

   ```js
   // setupProxy.js文件
   const { createProxyMiddleware } = require("http-proxy-middleware");
   module.exports = function (app) {
     app.use(
       "/api",
       createProxyMiddleware({
         target: "http://localhost:3008/api",
         changeOrigin: true,
       })
     );
   };
   
   // 必须支持es6才能结构出来，更改项目eslint文件，支持es6
   {
       "env": {
           "node": true,
           "es6": true
       },
       "parserOptions": {
           "ecmaVersion": 2018,
           "sourceType": "module"
       }
   }
   
   // 不使用es6写法
   var createProxyMiddleware =
     require("http-proxy-middleware").createProxyMiddleware;
   
   ```

   ## 路径别名
   
   npm install -D @craco/craco
   
   ```
   ```
   
   

# Node

## 使用环境变量

```js
npm install dotenv

require("dotenv").config(); // 在出口文件中使用，或者在需要使用环境变量的文件中使用
process.env.xxx 就可以访问到 .env文件中的环境变量了
```

## 使用token

```js
npm install jsonwebtoken express-jwt   // 生成token插件和中间件验证

const jwt = require("jsonwebtoken");
const privateKey = process.env.PRIVATE_KEY; // 生成的私钥
const userInfo = {userId:'123456'}
const token = jwt.sign({userInfo}, privateKey, {
        algorithm: "RS256",
        expiresIn: "1h",
      });
// 验证token，会将userInfo的数据从token解密出来
 const decoded = jwt.verify(token, publicKey);
```

## 使用OpenSSL工具，在命令行生成 private key和public key（RSA加密）

```js
// 生成公钥
openssl genrsa -out  private.pem 2048  // 生成的private的key放在private.pem文件中   位数为2048位

//从公钥中提取私钥
openssl rsa -in private.pem -outform PEM -pubout -out public.pem // 提取出来的私钥存放在public.pem 文件中
```

# 项目设计

## 菜单设计

**给角色加权限--通过权限匹配路由 -- 前后端共同管理权限**

## 敏感信息传输

- **rsa加密**
- **公钥、私钥全部由后端生成**
- **前端获取到公钥后存储在公共的地方**
- **前后端加解密key，必须只生成一次，不然会每启动一次后端，就会生成一个key对（推荐存在文件中）。不生成永久的就会导致加解密失败**

## 登录信息匹配

**账号密码是加密的，想要与库中的数据做匹配**

- 增加了字段  username_hash，username的哈希字段，用做索引和匹配表中的数据
  1. 登录信息---账号密码加密
  2. 后端取到入参，解密账号，然后将账号化作哈希值，username_hash
  3. 与表中的username_hash做比较（新增账号的时候会自动插入表中）
  4. 通过username_hash取出表中的数据，做逻辑匹配

## 路由监听（react-router 6+）

```ts
// 创建路由
const router = createBrowserRouter(routes)

// 创建路由监听 state 路由信息
router.subscribe((state) => {
    console.log(state, '路由subscribe');
})
```

## 判断访问路由是否需要登录

### 创建一个判断登录的组件

```tsx
import { JSX } from "react"
import { useSelector } from "react-redux"
import { Navigate } from 'react-router-dom'

const checkLogin = ({ children }: { children: JSX.Element }) => {
    const { isLogin } = useSelector((state: any) => state.auth)
    if (!isLogin) return <Navigate to={'/login'} />
    return children
}

export default checkLogin
// 如果没有登录则重定向登录页面
```

### 将判断登录的组件，嵌套在路由表中

```ts
// router.ts   
{
        path: "/",
        element: <CheckLogin><Layout /></CheckLogin>,
        name: "首页",
        icon: <Home theme="outline" size="18" />,
        children: [
            {
                path: "home",
                name: "首页",
                element: <HomePage />,
                hidden: true
            },
            {
                path: "",
                element: <Navigate to={'home'}></Navigate>,
                hidden: true
            }
        ]
    }
    
// 将Layout 嵌套在CheckLogin中，/ 地址下的所有路由地址，都会检查登录状态
    
//创建路由表
const router = createBrowserRouter(routes)
    
// App.ts
    
 return <RouterProvider router={router} />
 // 只需要接收router就行，登录判断全部都在路由文件中
```



